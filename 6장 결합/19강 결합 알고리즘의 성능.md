# 6장 결합
## 19강 결합 알고리즘의 성능

- 옵티마이저가 어떤 알고리즘을 선택할지 여부는 데이터 크기 또는 결합 키의 분산이라는 요인에 의존한다.
  - Nested Loops
    - 중첩 반복을 사용하는 알고리즘
    - 세부 처리
      1. 결합 테이블에서 레코드를 하나씩 반복해가며 스캔합니다. 이 테이블을 구동 테이블 또는 외부 테이블 이라고 부릅니다. 다른 테이블은 내부
      2. 구동 테이블의 레코드 하나마다 내부 테이블의 레코드를 하나씩 스캔해서 결합 조건에 맞으면 리턴합니다.
      3. 이러한 작동을 구동 테이블의 모든 레코드에 반복합니다.
    - 특징
      1. 실행시간은 레코드 수에 비례한다.
      2. 한 번의 단계에서 처리하는 레코드 수가 적으므로 Hash 또는 Sort Merge에 비해 메모리 소비가 적다.
      3. 모든 DBMS에서 지원한다.
    - 성능 개선 : 구동 테이블로는 작은 테이블을 선택하는 것? 
      -  내부 테이블의 결합 키 필드에 인덱스가 존재한다면....
      - 내부 테이블의 결합 키 필드에 인덱스가 존재한다면, 해당 인덱스를 통해 DBMS는 내부 테이블을 완전히 순환하지 않아도 된다.
      - 즉, 내부 테이블의 반복을 어느 정도 건너뛸 수 있게 된다.
      - 이상적인 경우는 구동 테이블의 레코드 한 개에 내부 테이블의 레코드 한 개가 대응하고, 해당 레코드를 내부 테이블의 인덱스를 사용해 찾을 수 있는 경우이다.
       ( 반복없이 찾을 수 있는 경우) => 반복 생략 가능
      - 내부 테이블의 결합 키 인덱스가 사용되지 않으면 구동 테이블이 작아봤자 아무런 장점이 없다. 
      - 구동 테이블을 작게 == 내부 테이블을 크게
      - 내부 테이블이 클수록 인덱스 사용으로 인한 반복 효과가 커지기 때문이다.
      - Nested Loops + 내부 테이블의 결합 키에 인덱스 조합 (SQL 튜닝의 기본)
      - 물리 ER 모델과 인덱스를 설정할때, 어떤 테이블을 내부 테이블로 하고, 어떤 결합 키에 인덱스를 작성해야 하는지 초기 단계부터 고민하자.
      - 단점
        - 결합키로 내부 테이블에 접근할 때 히트 되는 레코드가 너무 많을 때는 기대 만큼의 응답 시간이 나오지 않기도 하다.
        - 결합키가 내부 테이블에 대해 유일하지 않는 경우에 발생한다.
        - 절대적인 양이 너무 많으면 지연이 일어나게 된다.
        - 처리 방법
          - 구동 테이블로 큰 테이블을 선택하는 방법 : 하나의 레코드로 접근하는 것이 보장된다.
          - 극단적으로 성능이 저하 되는 것을 막을 수 있다.
  - Hash
    - Nested Loops의 문제점을 해결하기 위한 또다른 방법
    - 시스템 세계에서 굉장히 많이 사용된다.
    - 입력에 대해 어느 정도 유일성과 균일성을 가진 값을 출력하는 함수를 해시라고 한다.
    - 해시 결합은 작은 테이블을 스캔하고, 결합 키에 헤시 함수를 적용해서 해시값으로 변환합니다.
    - 이어서 다른 테이블을 스캔하고 결합 키가 해시 값에 존재하는 방법으로 수행합니다.
    - DBMS의 워킹 메모리에 저장되므로 조금이라고 작은 것이 효율적이다.
    - 특징
      - 결합 테이블로부터 해시 테이블을 만들어서 활용하므로, Nested Loops에 비해 메모리를 소모한다.
      - 메모리가 부족하면 저장소를 사용하므로 지연이 발생한다.
      - 출력되는 해시값은 입력값의 순서를 알지 못하므로, 등치 결합에만 사용할 수 있다.
    - Hash가 유용한 경우
      - Nested Loops에서 적절한 구동 테이블이 존재하지 않는 경우 'Nested Loops의 단점'에서 본 것 처럼 구동 테이블로 사용할만한 작은 테이블은 있지만,
        내부 테이블에서 히트되는 레코드 수가 너무 많은 경우
      - Nested Loops의 내부 테이블에서 인덱스가 존재하지 않는(또는 여러 가지 사정에 의해 인덱스를 추가할 수 없는) 경우
      - 즉, Nested Loops가 효율적으로 동작하지 않을때 사용하는 차선책이다.
      - 주의해야할점
        1. 초기에 해시 테이블을 만들어야 하므로, Nested Loops에 비해 소비하는 메모리의 양이 많다.
          - 동시 실행성이 높은 OLTP처리를 할때 Hash가 사용되면 DBMS가 사용할 수 있는 메모리가 부족해서 저장소가 사용된다.
          - 지연이 발생할 수 있다.
          - 따라서 OLTP를 사용할떄는 Hash는 사용하지 말자
          - 반대로, 동시 처리가 적은 야간 배치 또는 BI/DWH와 같은 시스템에 한해 사용하는 것이 Hash의 기본 전략이다.
        2. Hash 결합은 반드시 양쪽 테이블의 레코드를 전부 읽어야 하므로, 테이블 풀 스캔이 사용되는 경우가 많다.
          - 테이블의 규모가 굉장히 크면, 풀 스캔에 걸리는 시간도 고려해야한다. 
  - Sort Merge
    - 결합 테이블들을 각각 결합 키로 정렬하고 일치하는 결합 키를 찾으며 결합한다.
    - 특징
      - 대상 테이블을 모두 정렬해야 하므로 많은 메모리를 소비한다.
      - 동치 결합 뿐만아니라 부등호를 통한 결합이 가능하다(부정 조건은 안됨)
      - 원리적으로는 테이블이 결합 키로 정렬되어 있다면 정렬을 생략할 수 있다.
      - 테이블을 정렬하므로 한쪽 테이블을 모두 스캔한 시점에 결합을 완료할 수 있습니다.
  - 의도하지 않은 크로스 결합
    - 삼각결합
      ```mysql
      SELECT A.col_a. B.col_b, C.col_c
        FROM Table_A A
         INNER JOIN Table_B B
          ON A.col_a = B.col_b
         INNER JOIN Table_C C
          ON A.col_a = C.col_c 
      ```
      
      - 크로스 결합이 되는 이유
        - 옵티마이저가 어떤 로직으로 실행 계획을 선택하는지는 구현 의존적인 부분도 있으므로 어디까지나 추측에 불과하지만,
        - Table_B와 Table_C의 크기를 작다고 평가했을 가능성 때문일 수 있다.
        - 단순히 테이블의 크기가 클때뿐만 아니라, 검색 조건으로 히트되는 레코드 수가 변할 때도 발생한다.
        - 레코드 수를 제대로 압축 할 수 없는 입력이 들어왔을 때도 저장된 정보를 바탕으로 같은 실행을 선택해버리기 때문이다.
      - 회피 방법
      ```mysql
      SELECT A.col_a. B.col_b, C.col_c
        FROM Table_A A
         INNER JOIN Table_B B
          ON A.col_a = B.col_b
         INNER JOIN Table_C C
          ON A.col_a = C.col_c 
          AND C.col_c = B.col_b;  // 불필요한 결합 조건
      ```
